---
title: "Exploring the fiji methods on experiment 1647 all timepoints."
author: "atb abelew@gmail.com"
date: "`r Sys.Date()`"
output:
  html_document:
    code_download: true
    code_folding: show
    fig_caption: true
    fig_height: 7
    fig_width: 7
    highlight: zenburn
    keep_md: false
    mode: selfcontained
    number_sections: true
    self_contained: true
    theme: readable
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: false
---

<style type="text/css">
body, td {
  font-size: 16px;
}
code.r{
  font-size: 16px;
}
pre {
 font-size: 16px
}
</style>

```{r options, include=FALSE}
knitr::opts_knit$set(
  width = 120, progress = TRUE, verbose = TRUE, echo = TRUE)
knitr::opts_chunk$set(error = TRUE, dpi = 96)
lua_filters <- rmarkdown::pandoc_lua_filter_args("pandoc-zotxt.lua")
old_options <- options(
  digits = 4, stringsAsFactors = FALSE, knitr.duplicate.label = "allow")
ggplot2::theme_set(ggplot2::theme_bw(base_size = 10))
rundate <- format(Sys.Date(), format = "%Y%m%d")
previous_file <- ""
ver <- format(Sys.Date(), "%Y%m%d")

##tmp <- sm(loadme(filename=paste0(gsub(pattern="\\.Rmd", replace="", x=previous_file), "-v", ver, ".rda.xz")))
rmd_file <- "experiment_1647_all.Rmd"
library(spatstat.geom)
library(reticulate)
```

# Introduction

In this document I will attempt to test out the various ideas explored
in fiji_tracker and BBQ using a somewhat smaller dataset in the hopes
that I can more quickly and easily make changes.

The disadvantage is that the previous experimental file, while
massive, is relatively predictable to me.

# Loading the python modules

If I wrote the initialization for fiji_tracker correctly, I think not
too many import statements will be required.

```{python load}
from fiji_tracker.fiji_tracker.tracker import *

import os
import pandas
from pandas import DataFrame
from pathlib import Path

base_dir = Path('/lab/scratch/atb/imaging/mtb_2023').as_posix()
os.chdir(base_dir)
input_file = Path(f"{base_dir}/test_data/Experiment-1647_split_scenes-01.czi").as_posix()
pandas.set_option('display.max_columns', None)
verbose = True
```

# Start fiji

Note, I renamed the smaller test input file to remove a space in the
filename.

```{python start_fiji}
start_dir = os.getcwd()
mem = '-Xmx128g'
location = 'venv/bin/Fiji.app'
mode = 'interactive'

ij, raw_image, imp = start_fiji(base=start_dir, mem=mem, location=location, mode=mode,
                                input_file=input_file)
```

# Separate slices

I am not sure if this dataset should focus on a specific channel/Z.

```{python run_separate_slices}
raw_dataset, saved_slices, output_directory = separate_slices(
    input_file, ij, raw_image=raw_image, wanted_z=2, wanted_channel=3)
```

# Invoke cellpose

```{python run_invoke_cellpose}
output_files = invoke_cellpose(output_directory, 'models/CP_20220523_104016')
moved = move_cellpose_output(output_files)
```

# Collapse Z

I am not sure this is required for this image.

```{python run_collapse_z}
z_collapsed, z_collapsed_image, output_file, imp = collapse_z(raw_dataset, output_files, ij)
```

# Make measurements

Ok, I think I figured out why I have been having such difficulty with
this function!  I was using the imageplus handle on multiple open
files simultaneously without realizing it.  I removed that piece of
code, explicitly set the Z/C/Ts to 1-indexed values to start, and it
seems that all the ROIs are getting set to the correct places, and
associated with the appropriate times/etc.

```{python invoke_slice_to_roi}
slice_measurements = slices_to_roi_measurements(output_files, ij, z_collapsed_image,
                                                view_channel = 4, view_z = None)
```

# Send to pandas

```{python pandas}
concatenated = convert_slices_to_pandas(slice_measurements)

concatenated.shape[0]
concatenated.head()
```

# Nearest cells

```{python nearest_cells}
nearest, traced_ids, paired, pairwise_distances = nearest_cells_over_time(
    concatenated, max_dist = 10.0, x_column = 'X', y_column = 'Y')

add_overlays_to_groups(nearest, traced_ids, ij, imp)

for t in traced_ids:
    print(f"{t}: {traced_ids[t]}")
#traced_ids

written = write_nearest_cellids(nearest, output='nearest.csv')

measure_written = write_cell_measurements(traced_ids, paired,
                                         output='cell_measurements.csv')
print(f"Wrote the distances for {measure_written} parental cells.")
```

```{python test_cellpose_rois}
showPolygonRoi = scyjava.jimport('ij.gui.PolygonRoi')
Overlay = scyjava.jimport('ij.gui.Overlay')
Regions = scyjava.jimport('net.imglib2.roi.Regions')
LabelRegions = scyjava.jimport('net.imglib2.roi.labeling.LabelRegions')
ZProjector = scyjava.jimport('ij.plugin.ZProjector')()
ov = Overlay()
rm = ij.RoiManager.getRoiManager()
rm.runCommand("Associated", "true")
reset_range = imp.resetDisplayRanges()
reset = ij.py.run_macro('resetMinAndMax();')

output_dict = cellpose_result
cellpose_slices = list(cellpose_result.keys())
slice_number = 0
roi_index = 0
for slice_name in cellpose_slices:
    output_dict[slice_name]['slice_number'] = slice_number
    ## I am not sure if time is 0 or 1 indexed.
    timepoint = slice_number + 1
    print(f"Looking at slice: {slice_number} which is time: {timepoint}")
    imp.setT(timepoint)
    if (view_channel):
        imp.setC(view_channel)
    if (view_z):
        imp.setZ(view_z)
    input_tif = ''
    #if collapsed:
    #    input_tif = cellpose_result[slice_name]['collapsed_file']
    #else:
    #    input_tif = cellpose_result[slice_name]['input_file']
    #slice_dataset = ij.io().open(input_tif)
    #slice_data = ij.py.to_imageplus(slice_dataset)

    input_txt = cellpose_result[slice_name]['output_txt']
    input_mask = cellpose_result[slice_name]['output_mask']
    if verbose:
        print(f"Processing cellpose outline: {input_txt}")
        print(f"Measuring: {input_tif}")
    # convert Dataset to ImagePlus
    ## Added by ATB 20230712, maybe incorrect.
    ## The logic for this was taken from:
    ## https://stackoverflow.com/questions/73849418/is-there-any-way-to-switch-imagej-macro-code-to-python3-code

    ## Set up the measurement parameters
    set_string = f'Set Measurements...'
    measure_string = f'area mean min centroid median skewness kurtosis integrated stack redirect=None decimal=3'
    measure_setup = ij.IJ.run(set_string, measure_string)

    txt_fh = open(input_txt, 'r')
    roi_stats = defaultdict(list)
    slice_element = 0
    slice_roi_names = []
    for line in txt_fh:
        xy = line.rstrip().split(",")
        xy_coords = [int(element) for element in xy if element not in '']
        x_coords = [int(element) for element in xy[::2] if element not in '']
        y_coords = [int(element) for element in xy[1::2] if element not in '']
        xcoords_jint = JArray(JInt)(x_coords)
        ycoords_jint = JArray(JInt)(y_coords)
        polygon_roi_instance = scyjava.jimport('ij.gui.PolygonRoi')
        roi_instance = scyjava.jimport('ij.gui.Roi')
        imported_polygon = polygon_roi_instance(
            xcoords_jint, ycoords_jint, len(x_coords), int(roi_instance.POLYGON)
        )
        roi_name = f"t{slice_number}_c{slice_element}"
        slice_roi_names.append(roi_name)
        imp.setRoi(imported_polygon)
        added = rm.addRoi(imported_polygon)
        current_index = rm.getCount() - 1
        current_name = rm.getName(current_index)
        renamed = rm.rename(current_index, roi_name)
        selected = rm.select(current_index)
        imp.setT(timepoint)
        if (view_channel):
            imp.setC(view_channel)
        #if (view_z):
        #    imp.setZ(view_z)
        rm.runCommand("Update")
        slice_element = slice_element + 1
        roi_index = roi_index + 1
        measured = ij.IJ.run(imp, 'Measure', '')
        ## All ROIs for this frame have been measured, send the results back to a dataframe
    txt_fh.close()
    slice_result = ij.ResultsTable.getResultsTable()
    slice_table = ij.convert().convert(
        slice_result, scyjava.jimport('org.scijava.table.Table')
    )
    slice_measurements = ij.py.from_java(slice_table)
    slice_measurements['cell_id'] = slice_roi_names
    output_dict[slice_name]['measurements'] = slice_measurements
    ij.IJ.run('Clear Results')
    imp.show()
    imp.setOverlay(ov)
    slice_number = slice_number + 1
    ## All frames have been measured


```
