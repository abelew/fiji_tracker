---
title: "Exploring the fiji methods on experiment 1647 all timepoints."
author: "atb abelew@gmail.com"
date: "`r Sys.Date()`"
output:
  html_document:
    code_download: true
    code_folding: show
    fig_caption: true
    fig_height: 7
    fig_width: 7
    highlight: zenburn
    keep_md: false
    mode: selfcontained
    number_sections: true
    self_contained: true
    theme: readable
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: false
---

<style type="text/css">
body, td {
  font-size: 16px;
}
code.r{
  font-size: 16px;
}
pre {
 font-size: 16px
}
</style>

```{r options, include=FALSE}
knitr::opts_knit$set(
  width = 120, progress = TRUE, verbose = TRUE, echo = TRUE)
knitr::opts_chunk$set(error = TRUE, dpi = 96)
lua_filters <- rmarkdown::pandoc_lua_filter_args("pandoc-zotxt.lua")
old_options <- options(
  digits = 4, stringsAsFactors = FALSE, knitr.duplicate.label = "allow")
ggplot2::theme_set(ggplot2::theme_bw(base_size = 10))
rundate <- format(Sys.Date(), format = "%Y%m%d")
previous_file <- ""
ver <- format(Sys.Date(), "%Y%m%d")

##tmp <- sm(loadme(filename=paste0(gsub(pattern="\\.Rmd", replace="", x=previous_file), "-v", ver, ".rda.xz")))
rmd_file <- "experiment_1647_all.Rmd"
library(spatstat.geom)
library(reticulate)
```

# Introduction

In this document I will attempt to test out the various ideas explored
in fiji_tracker and BBQ using a somewhat smaller dataset in the hopes
that I can more quickly and easily make changes.

The disadvantage is that the previous experimental file, while
massive, is relatively predictable to me.

# Loading the python modules

If I wrote the initialization for fiji_tracker correctly, I think not
too many import statements will be required.

```{python load}
from fiji_tracker.fiji_tracker.tracker import *

import os
import pandas
from pandas import DataFrame
from pathlib import Path

base_dir = Path('/lab/scratch/atb/imaging/mtb_2023').as_posix()
os.chdir(base_dir)
input_file = Path(f"{base_dir}/test_data/Experiment-1647_split_scenes-01.czi").as_posix()
pandas.set_option('display.max_columns', None)
verbose = True

```

# Start fiji

Note, I renamed the smaller test input file to remove a space in the
filename.

```{python start_fiji}

start_dir = os.getcwd()
mem = '-Xmx128g'
location = 'venv/bin/Fiji.app'
mode = 'interactive'

ij, raw_image, imp = start_fiji(base=start_dir, mem=mem, location=location, mode=mode,
                                input_file=input_file)

```

# Separate slices

I am not sure if this dataset should focus on a specific channel/Z.

```{python run_separate_slices}

raw_dataset, saved_slices, output_directory = separate_slices(
    input_file, ij, raw_image=raw_image, wanted_z=2, wanted_channel=3)

```

# Invoke cellpose

```{python run_invoke_cellpose}

output_files = invoke_cellpose(output_directory, 'models/CP_20220523_104016')
moved = move_cellpose_output(output_files)

```

# Collapse Z

I am not sure this is required for this image.  Note, the collapse_z
function has a parameter named 'wanted_channel' which defaults to '3'
and may be changed to specify the correct channel of interest.

```{python run_collapse_z}

z_collapsed, z_collapsed_image, output_file, imp = collapse_z(raw_dataset, output_files, ij,
                                                              method='sum all',
                                                              wanted_channel=3)

```

# Make measurements

Ok, I think I figured out why I have been having such difficulty with
this function!  I was using the imageplus handle on multiple open
files simultaneously without realizing it.  I removed that piece of
code, explicitly set the Z/C/Ts to 1-indexed values to start, and it
seems that all the ROIs are getting set to the correct places, and
associated with the appropriate times/etc.

```{python invoke_slice_to_roi}

imp = ij.py.to_imageplus(z_collapsed)
## I think I would like to have this function be smart enough to know
## If the input is an imageplus or raw image and convert without intervention.
slice_measurements = slices_to_roi_measurements(output_files, ij, imp,
                                                view_channel=4, view_z=None, collapsed=True)

```

# Send to pandas

```{python pandas}

concatenated = convert_slices_to_pandas(slice_measurements)
concatenated.shape[0]
concatenated.head()

```

# Nearest cells

```{python nearest_cells}

nearest, traced_ids, paired, pairwise_distances = nearest_cells_over_time(
    concatenated, max_dist = 100.0, x_column = 'X', y_column = 'Y')
add_overlays_to_groups(nearest, traced_ids, ij, imp)
for t in traced_ids:
    print(f"{t}: {traced_ids[t]}")
#traced_ids
written = write_nearest_cellids(nearest, output='nearest.csv')
measure_written = write_cell_measurements(traced_ids, paired,
                                         output='cell_measurements.csv')
print(f"Wrote the distances for {measure_written} parental cells.")

```

An example of rereading the nearest csv, cleaning it up a little, and selecting ROIs with it.
With a couple of caveats, I didn't define rm I think.
This example will iterate over every cell in the csv file and pull
them, which is a bit excessive and likely should be just used on a few
cells of interest.

```{python reread_csv, eval=FALSE}

testing = pandas.read_csv('nearest.csv')
for row_number in range(len(testing)):
    single_row = testing.iloc[row_number]
    row_cellids = single_row.child_cell_ids
    row_cleaned = row_cellids.strip('[').strip(']')
    row_array = row_cleaned.split(', ')
    for cell in row_array:
        print(f"This row has cell: {cell}")
        cell_index = int(cell)
        roi = rm.select(cell_index)

```

# Cell trajectory?

```{python cell_trajectory}

cell_id = "t87_c11"
cell_idx = nearest[cell_id]
cell_data = pairwise_distances.loc[cell_idx]
len(cell_data)
cell_data = cell_data.reset_index()

scatter = plt.scatter(cell_data['X'], cell_data['Y'])
final_row = cell_data.index.max()
for start_time in range(0, final_row - 1):
    ti_idx = cell_data.index == start_time
    tj_idx = cell_data.index == start_time + 1
    p1x = cell_data[ti_idx].X
    p2x = cell_data[tj_idx].X
    p1y = cell_data[ti_idx].Y
    p2y = cell_data[tj_idx].Y
    x_points = [p1x, p2x]
    y_points = [p1y, p2y]
    plt.plot(x_points, y_points)
finalm1_idx = cell_data.index == final_row - 1
final_idx = cell_data.index == final_row
finalm1_x = cell_data[finalm1_idx].X
final_x = cell_data[final_idx].X
finalm1_y = cell_data[finalm1_idx].Y
final_y = cell_data[final_idx].Y
x_points = [finalm1_x, final_x]
y_points = [finalm1_y, final_y]
plt.plot(x_points, y_points)
plt.show()

seaborn.violinplot(data = cell_data.Area)
plt.show()

```
